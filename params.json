{
  "name": "Touchstone",
  "tagline": "Need for Automation",
  "body": "# TOUCHSTONE\r\n\r\n- Thoughts on testing practices\r\n- Ideas and implementation or reuse of best fit libraries for automation\r\n\r\n### Need for a Test Automation\r\n- It has been a desire to achieve test automation so that a developer can \r\n  - make as well as verify her continuous changes to the code base\r\n  - without worrying about any regressions\r\n- We have unit tests to satify just that. Don't we ?\r\n  - What about the areas that unit tests can not cover ?\r\n- So we need some form of automation:\r\n  - that can remove the repetitive (read manual) tasks\r\n  - fasten the overall delivery process\r\n \r\n### What kind of Test Automation should we implement ?\r\n#### We shall start with unit tests\r\nLet me quote an email from OpenStack forums: \r\n>**\"** If a method is conceivably testable with unit tests (without over relying on mock), \r\n>that is preferable. Failing that, functional tests are the way to go. \r\n>The general idea is to test bottom up: \r\n>+    Lots of unit tests,\r\n>+    fewer functional tests,\r\n>+    fewer API/integration/fullstack tests,\r\n>\r\n>It is difficult to test the agent with unit tests effectively, \r\n>which is why I encourage developers to test via functional, mock-less tests. **\"**\r\n\r\nThis is another quote from James Strachan's Weblog - Friday Aug 29, 2003\r\n\r\n>**\"**\r\n>I'm finding that most time spent in a TDD style development model is \r\n>+ coding the unit tests. \r\n>\r\n>There's typically lots of unit test code for little application code. \r\n>Also there does seem to be some baggage when writing unit tests in java. \r\n>This seems a great opportunity for using a concise & powerful dynamically typed language. \r\n>**\"**\r\n\r\n#### For a moment, lets think about the issues implementing unit tests:\r\n+ Brittle unit tests\r\n+ No end to writing unit tests\r\n\r\n#### Below items poses very generic queries on other forms of testing\r\n- Here too, we have lots of tools/libraries to choose from.\r\n- However, we should filter them through below checklists:\r\n    - Are they simple enough to use ?\r\n    - Easy enough for a non-technical person to add/modify the test routines\r\n    - Resource need not spend hours to do so\r\n    - Resource may imply a QA engineer, Business Analyst, or an Admin.\r\n    - Can they be run or atleast triggered from one's laptop ?\r\n    - The tools & corresponding test cases would be fine tuned \r\n      - & later be moved to some build setups.\r\n- To summarize, it will be good to have test tool(s) that can be \r\n  - easy to plugin to existing tools\r\n  - quick to develop, \r\n  - easy to run,\r\n  - exposed in form of some DSLs/builders\r\n  - easy to set up in different environments.\r\n  - i.e. a unified testing layer that can accomodate all the above\r\n\r\n#### Solutions to mitigate issues that we talked about:\r\n+ Wide variety of tools make writing unit testing a breeze.\r\n  + e.g. property based testing via [scalacheck](http://www.scalacheck.org/)\r\n  + e.g. data driven testing via [spock](http://spockframework.github.io/spock/docs/)\r\n+ Writing code using functional ways\r\n  + e.g. one may write java or python code thinking of functional constructs\r\n  + e.g. java has java.util.function package\r\n  + this reduces the lines of code\r\n  + this in turn reduces the effort spent on writing unit test code\r\n  + remember less code implies less bugs\r\n  + leads to unit tests without 'mocks' \r\n  + leads to running tests locally that are more closer to production environment.\r\n+ Use of IDEs\r\n+ Use of static tools for linting the code\r\n  + these will help us find out a lot of bugs during code itself\r\n+ Use of functional languages\r\n  + these requires a significant leap of faith\r\n  + if we do manage this the benefits are plenty\r\n  + we end up writing clear, concise, better intent, readable & testable code\r\n  + source code as well as unit test code is not longer brittle\r\n  + this approach defintely tackles bugs & issues in a proactive manner\r\n+ With these in mind we shall venture out:\r\n  + to design & build or reuse some library that creates the Unified Automation Platform\r\n  \r\n\r\n### What other innovations matter w.r.t automation ?\r\n+ tool to inject faults & verify the resiliency of the system.\r\n  + dedicated thought process needs to go into crafting the fault injection methods.\r\n\r\n### Related Links\r\n\r\n- [Rest API Testing](https://github.com/vlucas/frisby)\r\n- [Rest API Bench Testing](https://github.com/jeffbski/bench-rest)\r\n- [You cannot test all the things](https://dzone.com/articles/you-cant-test-all-the-things-api-iot-roi-tbd?utm_content=bufferbf217&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer)\r\n- [Unit Testing](http://www.lingua-systems.com/unit-testing/)\r\n- [Spock](https://github.com/spockframework/spock)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}